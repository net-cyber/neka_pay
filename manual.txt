<think>
Let me outline the specific steps for adding a new feature to this particular codebase, which follows a specific pattern of database-first development with SQL, SQLC, Go handlers, and gin routes.

Looking at the existing codebase, I can see they follow this pattern:
1. Create SQL migrations to define database schema
2. Define SQL queries 
3. Generate Go code from SQL with SQLC
4. Create handler functions in the API package
5. Register routes in the server
6. Test the functionality

I'll create a step-by-step guide specific to this codebase's architecture.
</think>

# General Steps for Adding New Features to This Codebase

Based on your specific codebase architecture, here are the systematic steps to add any new feature:

## 1. Create Database Migration Files
```bash
# Create migration files (up and down)
touch db/migration/00000X_feature_name.up.sql
touch db/migration/00000X_feature_name.down.sql
```

- Define your table schema in the `.up.sql` file
- Define the cleanup steps in the `.down.sql` file
- Run `make migrateup` to apply the migrations

## 2. Define SQL Queries
```bash
# Create a new query file
touch db/query/feature_name.sql
```

- Define CRUD operations (Create, Read, Update, Delete)
- Include any specialized queries needed for your feature
- Follow the naming conventions you've established (e.g., `:one`, `:many`, `:exec`)

## 3. Generate Go Database Code
```bash
# Generate SQLC code
make sqlc
```

- This will generate Go code in `db/sqlc/` directory
- Check the generated files for your new feature

## 4. Add Business Logic to Store (if needed)
- If your feature requires transactions or complex operations:
  - Extend the `Store` struct in `db/sqlc/store.go`
  - Add methods like `YourFeatureTx` similar to the existing `TransferTx`

## 5. Write Database Tests
```bash
# Create a test file for your feature
touch db/sqlc/feature_name_test.go
```

- Write tests for all generated database operations
- Include edge cases and error scenarios
- Run tests with `make test`

## 6. Create API Handlers
```bash
# Create a new API file
touch api/feature_name.go
```

- Define request/response structs
- Implement handler functions (create, get, list, update, delete)
- Add validation logic
- Connect to the database layer

## 7. Register Routes in Server
```go
// Update api/server.go to add your new routes
func NewServer(store *db.Store) *Server {
    // ...existing code...
    
    // Add your feature routes
    router.POST("/your_feature", server.createYourFeature)
    router.GET("/your_feature/:id", server.getYourFeature)
    router.GET("/your_feature", server.listYourFeature)
    router.PUT("/your_feature/:id", server.updateYourFeature)
    router.DELETE("/your_feature/:id", server.deleteYourFeature)
    
    // ...existing code...
}
```

## 8. Update Main.go (if needed)
- If your feature requires new configuration or dependencies
- Update the main function to initialize them

## 9. Manual Testing
```bash
# Start the server
make server

# Test with curl or Postman
curl -X POST http://localhost:8080/your_feature -d '{"field": "value"}'
```

## 10. Add to CI/CD (if applicable)
- Ensure your tests run in the GitHub workflow
- Update any documentation

This pattern follows your codebase's existing structure and will help maintain consistency across your banking application as you add new features.


<think>
I see - I misunderstood the requirement. The user wants to have a single account entity that can hold multiple currencies, rather than multiple account records for each currency. This is a different data model than what's currently implemented.

Let me think about how to redesign this:

1. We need to change the account table to not have a "currency" field anymore, since an account will support multiple currencies
2. We'll need a new table like "account_balance" that links to an account and stores balances for different currencies
3. The schema will need to be updated, and the constraint would be on the account_balance table instead

Let me sketch out what this new schema would look like and the migration needed.
</think>

# Revised Schema: One Account with Multiple Currencies

I misunderstood your requirement. You want a single account that can hold multiple currencies internally, rather than separate account records for each currency. Here's how to restructure your database schema:

## Database Schema Changes

```sql:db/migration/000002_redesign_account_currency.up.sql
-- First create a new table for account balances
CREATE TABLE "account_balance" (
  "id" bigserial PRIMARY KEY,
  "account_id" bigint NOT NULL,
  "currency" varchar NOT NULL,
  "amount" bigint NOT NULL,
  "created_at" timestamptz NOT NULL DEFAULT (now()),
  "updated_at" timestamptz NOT NULL DEFAULT (now())
);

-- Add foreign key
ALTER TABLE "account_balance" ADD FOREIGN KEY ("account_id") REFERENCES "account" ("id");

-- Add unique constraint to ensure one currency per account
ALTER TABLE "account_balance" ADD CONSTRAINT "account_currency_key" UNIQUE ("account_id", "currency");

-- Create index for faster lookups
CREATE INDEX ON "account_balance" ("account_id");

-- Remove the currency and balance from the account table
ALTER TABLE "account" DROP COLUMN "currency";
ALTER TABLE "account" DROP COLUMN "balance";

-- Modify transfer table to reference account_balance instead of account
ALTER TABLE "transfer" ADD COLUMN "from_balance_id" bigint;
ALTER TABLE "transfer" ADD COLUMN "to_balance_id" bigint;

-- Add foreign keys
ALTER TABLE "transfer" ADD FOREIGN KEY ("from_balance_id") REFERENCES "account_balance" ("id");
ALTER TABLE "transfer" ADD FOREIGN KEY ("to_balance_id") REFERENCES "account_balance" ("id");

-- Update entry table to reference account_balance
ALTER TABLE "entry" ADD COLUMN "balance_id" bigint;
ALTER TABLE "entry" ADD FOREIGN KEY ("balance_id") REFERENCES "account_balance" ("id");
```

```sql:db/migration/000002_redesign_account_currency.down.sql
-- Revert all changes
ALTER TABLE "entry" DROP COLUMN "balance_id";
ALTER TABLE "transfer" DROP COLUMN "to_balance_id";
ALTER TABLE "transfer" DROP COLUMN "from_balance_id";

ALTER TABLE "account" ADD COLUMN "currency" varchar;
ALTER TABLE "account" ADD COLUMN "balance" bigint;

DROP TABLE "account_balance";
```

## Updated Schema Diagram

```
+-------------------+            +-------------------+
|      account      |            |  account_balance  |
+-------------------+            +-------------------+
| id (PK)           |<---------->| id (PK)           |
| owner             |            | account_id (FK)   |
| created_at        |            | currency          |
+-------------------+            | amount            |
                                 | created_at        |
                                 | updated_at        |
                                 +-------------------+
                                        ^   ^
                                        |   |
                                        v   v
+-------------------+            +-------------------+
|      entry        |            |     transfer      |
+-------------------+            +-------------------+
| id (PK)           |            | id (PK)           |
| account_id (FK)   |            | from_account_id   |
| balance_id (FK)   |            | to_account_id     |
| amount            |            | from_balance_id   |
| created_at        |            | to_balance_id     |
+-------------------+            | amount            |
                                 | currency          |
                                 | created_at        |
                                 +-------------------+
```

## Example Data (New Structure)

```
-- account table
| id | owner | created_at          |
|----|-------|---------------------|
| 1  | john  | 2023-09-10 14:30:00 |

-- account_balance table
| id | account_id | currency | amount | created_at          | updated_at          |
|----|------------|----------|--------|---------------------|---------------------|
| 1  | 1          | USD      | 500    | 2023-09-10 14:30:00 | 2023-09-10 14:30:00 |
| 2  | 1          | ETB      | 10000  | 2023-09-10 14:35:00 | 2023-09-10 14:35:00 |
```

This design allows a single account to hold multiple currencies, tracking each currency balance separately. The unique constraint on `(account_id, currency)` ensures a user can have only one balance per currency within their account.

You'll need to update your application logic significantly to work with this new schema, including creating new SQL queries, handlers, and domain logic for managing account balances.
